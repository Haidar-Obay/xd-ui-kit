


import React, { useState, useEffect, useMemo, useRef } from 'react';
import { Search, Filter, CheckSquare, Square, ChevronDown, ChevronRight } from 'lucide-react';
import _ from 'lodash';

// Enhanced Data Table Component with advanced features
export const Table = ({ 
  data: initialData = [], 
  columns: initialColumns = [],
  onRowClick = null,
  onCellValueChange = null,
  // Dynamic styling options
  styles = {
    headerBgColor: '#f9fafb',
    rowHoverColor: '#f3f4f6',
    selectedRowColor: '#eff6ff',
    borderColor: '#e5e7eb',
    textColor: '#374151',
    headerTextColor: '#111827',
    showRowBorders: true,
    showColumnBorders: true,
    stickyHeader: true,
    stickyFirstColumn: false,
    rowHeight: 'default', // 'compact', 'default', 'relaxed'
  },
  // Feature flags
  features = {
    inlineEditing: true,
    rowExpansion: true,
    multiSelect: true,
    draggableRows: true,
    draggableColumns: true,
    saveState: true,
    liveSearch: true,
  },
  // Table state identifier for localStorage
  stateId = 'data-table-state',
  // Row expansion render function
  renderExpandedRow = null,
  // Custom cell renderer functions
  cellRenderers = {},
  searchDebounceTime = 300,
}) => {
  // State management
  const [data, setData] = useState(initialData);
  const [columns, setColumns] = useState(initialColumns);
  const [visibleColumns, setVisibleColumns] = useState([]);
  const [columnOrder, setColumnOrder] = useState([]);
  const [filters, setFilters] = useState({});
  const [globalSearch, setGlobalSearch] = useState('');
  const [debouncedSearch, setDebouncedSearch] = useState('');
  const [sortConfig, setSortConfig] = useState({ key: null, direction: null });
  const [selectedRows, setSelectedRows] = useState([]);
  const [expandedRows, setExpandedRows] = useState([]);
  const [editingCell, setEditingCell] = useState(null);
  const [isFilterOpen, setIsFilterOpen] = useState(false);
  const [recentSearches, setRecentSearches] = useState([]);
  
  const filterRef = useRef(null);
  const tableRef = useRef(null);
  const headerRef = useRef(null);
  const firstColRef = useRef(null);
  const editCellInputRef = useRef(null);
  const dragItem = useRef(null);
  const dragOverItem = useRef(null);
  const dragColumnItem = useRef(null);
  const dragOverColumnItem = useRef(null);
  
  // Setup column order and visibility on init and when columns change
  useEffect(() => {
    if (columns.length > 0) {
      // Set initial column order if not already set
      if (columnOrder.length === 0) {
        setColumnOrder(columns.map(col => col.id));
      }
      
      // Set initial visible columns if not already set
      if (visibleColumns.length === 0) {
        setVisibleColumns(columns.map(col => col.id));
      }
    }
  }, [columns]);
  
  // Load saved state from localStorage
  useEffect(() => {
    if (features.saveState) {
      const savedState = localStorage.getItem(stateId);
      if (savedState) {
        try {
          const parsedState = JSON.parse(savedState);
          if (parsedState.visibleColumns) setVisibleColumns(parsedState.visibleColumns);
          if (parsedState.columnOrder) setColumnOrder(parsedState.columnOrder);
          if (parsedState.sortConfig) setSortConfig(parsedState.sortConfig);
          if (parsedState.recentSearches) setRecentSearches(parsedState.recentSearches);
        } catch (e) {
          console.error('Error parsing saved table state', e);
        }
      }
    }
  }, [features.saveState, stateId]);
  
  // Save state to localStorage whenever it changes
  useEffect(() => {
    if (features.saveState) {
      const stateToSave = {
        visibleColumns,
        columnOrder,
        sortConfig,
        recentSearches
      };
      localStorage.setItem(stateId, JSON.stringify(stateToSave));
    }
  }, [visibleColumns, columnOrder, sortConfig, recentSearches, features.saveState, stateId]);
  
  // Set up sticky header and first column behavior
  useEffect(() => {
    const applySticky = () => {
      if (!tableRef.current) return;
      
      if (styles.stickyHeader && headerRef.current) {
        const header = headerRef.current;
        header.style.position = 'sticky';
        header.style.top = '0';
        header.style.zIndex = '10';
        header.style.backgroundColor = styles.headerBgColor;
      }
      
      if (styles.stickyFirstColumn && firstColRef.current) {
        const firstCol = firstColRef.current;
        const firstColCells = tableRef.current.querySelectorAll('.first-col');
        firstColCells.forEach(cell => {
          cell.style.position = 'sticky';
          cell.style.left = '0';
          cell.style.zIndex = '5';
          cell.style.backgroundColor = 'inherit';
        });
      }
    };
    
    applySticky();
  }, [styles.stickyHeader, styles.stickyFirstColumn]);
  
  // Handle outside clicks to close dropdowns
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (filterRef.current && !filterRef.current.contains(event.target)) {
        setIsFilterOpen(false);
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);
  
  // Focus the input when editing a cell
  useEffect(() => {
    if (editingCell && editCellInputRef.current) {
      editCellInputRef.current.focus();
    }
  }, [editingCell]);

  // Debounce search input
  useEffect(() => {
    if (!features.liveSearch) {
      setDebouncedSearch(globalSearch);
      return;
    }
    
    const handler = setTimeout(() => {
      setDebouncedSearch(globalSearch);
      
      // Save to recent searches if not empty and not already in list
      if (globalSearch && globalSearch.trim() !== '') {
        setRecentSearches(prev => {
          const newSearches = [globalSearch, ...prev.filter(s => s !== globalSearch)].slice(0, 5);
          return newSearches;
        });
      }
    }, searchDebounceTime);
    
    return () => {
      clearTimeout(handler);
    };
  }, [globalSearch, searchDebounceTime, features.liveSearch]);
  
  // Sort function
  const requestSort = (key) => {
    let direction = 'asc';
    if (sortConfig.key === key && sortConfig.direction === 'asc') {
      direction = 'desc';
    }
    setSortConfig({ key, direction });
  };

  // Filter function
  const handleFilterChange = (columnId, value) => {
    setFilters(prev => ({
      ...prev,
      [columnId]: value
    }));
  };

  // Column visibility toggle
  const toggleColumnVisibility = (columnId) => {
    setVisibleColumns(prev => 
      prev.includes(columnId)
        ? prev.filter(id => id !== columnId)
        : [...prev, columnId]
    );
  };

  // Select all rows
  const toggleSelectAll = () => {
    if (selectedRows.length === filteredData.length) {
      setSelectedRows([]);
    } else {
      setSelectedRows(filteredData.map(row => row.id));
    }
  };

  // Select individual row
  const toggleRowSelection = (e, rowId) => {
    e.stopPropagation();
    setSelectedRows(prev => 
      prev.includes(rowId)
        ? prev.filter(id => id !== rowId)
        : [...prev, rowId]
    );
  };
  
  // Toggle row expansion
  const toggleRowExpansion = (rowId) => {
    setExpandedRows(prev => 
      prev.includes(rowId)
        ? prev.filter(id => id !== rowId)
        : [...prev, rowId]
    );
  };
  
  // Handle double click to edit cell
  const handleCellDoubleClick = (rowId, columnId, currentValue) => {
    if (!features.inlineEditing) return;
    if (!onCellValueChange) return;
    
    const column = columns.find(col => col.id === columnId);
    if (column && column.editable === false) return;
    
    setEditingCell({ rowId, columnId, value: currentValue });
  };
  
  // Handle cell edit complete
  const handleCellEditComplete = (e) => {
    if (!editingCell) return;
    
    const { rowId, columnId, value } = editingCell;
    const newValue = e.target.value;
    
    if (newValue !== value) {
      // Call parent handler
      if (onCellValueChange) {
        onCellValueChange(rowId, columnId, newValue);
      }
      
      // Update local data
      setData(prevData => 
        prevData.map(row => 
          row.id === rowId 
            ? { ...row, [columnId]: newValue } 
            : row
        )
      );
    }
    
    setEditingCell(null);
  };
  
  // Handle dragging rows
  const handleRowDragStart = (e, index) => {
    if (!features.draggableRows) return;
    dragItem.current = index;
    e.dataTransfer.effectAllowed = "move";
  };
  
  const handleRowDragOver = (e, index) => {
    if (!features.draggableRows) return;
    e.preventDefault();
    dragOverItem.current = index;
  };
  
  const handleRowDragEnd = () => {
    if (!features.draggableRows || dragItem.current === null || dragOverItem.current === null) return;
    
    const newData = [...filteredData];
    const itemToMove = newData[dragItem.current];
    newData.splice(dragItem.current, 1);
    newData.splice(dragOverItem.current, 0, itemToMove);
    
    setData(newData);
    dragItem.current = null;
    dragOverItem.current = null;
  };
  
  // Handle dragging columns
  const handleColumnDragStart = (e, index) => {
    if (!features.draggableColumns) return;
    dragColumnItem.current = index;
    e.dataTransfer.effectAllowed = "move";
  };
  
  const handleColumnDragOver = (e, index) => {
    if (!features.draggableColumns) return;
    e.preventDefault();
    dragOverColumnItem.current = index;
  };
  
  const handleColumnDragEnd = () => {
    if (!features.draggableColumns || dragColumnItem.current === null || dragOverColumnItem.current === null) return;
    
    const newOrder = [...columnOrder];
    const itemToMove = newOrder[dragColumnItem.current];
    newOrder.splice(dragColumnItem.current, 1);
    newOrder.splice(dragOverColumnItem.current, 0, itemToMove);
    
    setColumnOrder(newOrder);
    dragColumnItem.current = null;
    dragOverColumnItem.current = null;
  };

  // Apply filters, sorting, and global search
  const filteredData = useMemo(() => {
    let result = [...initialData];
    
    // Apply column filters
    Object.entries(filters).forEach(([columnId, filterValue]) => {
      if (filterValue && filterValue.length > 0) {
        result = result.filter(row => {
          const cellValue = String(row[columnId] || '').toLowerCase();
          return cellValue.includes(filterValue.toLowerCase());
        });
      }
    });
    
    // Apply global search
    if (debouncedSearch) {
      const searchTerm = debouncedSearch.toLowerCase();
      result = result.filter(row => {
        return visibleColumns.some(columnId => {
          const column = columns.find(col => col.id === columnId);
          if (!column) return false;
          const cellValue = String(row[columnId] || '').toLowerCase();
          return cellValue.includes(searchTerm);
        });
      });
    }
    
    // Apply sorting
    if (sortConfig.key) {
      result.sort((a, b) => {
        const aValue = a[sortConfig.key];
        const bValue = b[sortConfig.key];
        
        if (aValue < bValue) {
          return sortConfig.direction === 'asc' ? -1 : 1;
        }
        if (aValue > bValue) {
          return sortConfig.direction === 'asc' ? 1 : -1;
        }
        return 0;
      });
    }
    
    return result;
  }, [initialData, filters, debouncedSearch, sortConfig, visibleColumns, columns]);

  // Row height class
  const getRowHeightClass = () => {
    switch (styles.rowHeight) {
      case 'compact': return 'py-1';
      case 'relaxed': return 'py-4';
      default: return 'py-2';
    }
  };
  
  // Dynamic border styles
  const getBorderStyle = () => {
    return {
      borderColor: styles.borderColor,
      borderStyle: 'solid',
      borderWidth: '0',
      ...(styles.showColumnBorders ? { borderRightWidth: '1px' } : {}),
      ...(styles.showRowBorders ? { borderBottomWidth: '1px' } : {})
    };
  };
  
  // Render cell value with custom renderer if provided
  const renderCellValue = (row, columnId) => {
    const value = row[columnId];
    const customRenderer = cellRenderers[columnId];
    
    if (customRenderer) {
      return customRenderer(value, row);
    }
    
    return value;
  };
  
  // Empty state
  if (filteredData.length === 0) {
    return (
      <div className="w-full border rounded p-8" style={{ borderColor: styles.borderColor }}>
        <div className="flex flex-col items-center justify-center">
          <div className="bg-gray-100 p-6 rounded-full mb-4">
            <Filter size={32} className="text-gray-400" />
          </div>
          <h3 className="text-lg font-medium mb-2" style={{ color: styles.headerTextColor }}>No data found</h3>
          <p className="text-gray-500 text-center mb-4">
            {debouncedSearch || Object.values(filters).some(Boolean) 
              ? "Your search or filter criteria didn't match any records. Try adjusting your filters."
              : "There are no records to display yet."}
          </p>
          {(debouncedSearch || Object.values(filters).some(Boolean)) && (
            <button 
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
              onClick={() => {
                setGlobalSearch('');
                setDebouncedSearch('');
                setFilters({});
              }}
            >
              Clear all filters
            </button>
          )}
        </div>
      </div>
    );
  }

  return (
    <div className="w-full border rounded" 
      style={{ borderColor: styles.borderColor, color: styles.textColor }} 
      ref={tableRef}
    >
      {/* Toolbar */}
      <div className="flex flex-wrap items-center justify-between p-4 border-b" style={{ borderColor: styles.borderColor }}>
        <div className="flex items-center space-x-2 mb-2 sm:mb-0">
          {/* Global search */}
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={16} />
            <input
              type="text"
              placeholder="Search all columns..."
              className="pl-10 pr-4 py-2 border rounded w-64 focus:outline-none focus:ring-2 focus:ring-blue-500"
              style={{ borderColor: styles.borderColor }}
              value={globalSearch}
              onChange={(e) => setGlobalSearch(e.target.value)}
              list="recent-searches"
            />
            {recentSearches.length > 0 && (
              <datalist id="recent-searches">
                {recentSearches.map((search, index) => (
                  <option key={index} value={search} />
                ))}
              </datalist>
            )}
          </div>
          
          {/* Filter button */}
          <div className="relative" ref={filterRef}>
            <button
              className="flex items-center px-3 py-2 border rounded hover:bg-gray-50"
              style={{ borderColor: styles.borderColor }}
              onClick={() => setIsFilterOpen(!isFilterOpen)}
            >
              <Filter size={16} className="mr-2" />
              Filters
              {Object.values(filters).some(Boolean) && (
                <span className="ml-2 bg-blue-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs">
                  {Object.values(filters).filter(Boolean).length}
                </span>
              )}
            </button>
            
            {isFilterOpen && (
              <div 
                className="absolute left-0 mt-2 w-64 bg-white border rounded shadow-lg z-10"
                style={{ borderColor: styles.borderColor }}
              >
                <div className="p-3 border-b font-medium" style={{ borderColor: styles.borderColor }}>
                  Column Filters
                </div>
                <div className="max-h-96 overflow-y-auto p-2">
                  {columns.map(column => (
                    <div key={column.id} className="mb-3">
                      <label className="block text-sm font-medium mb-1">{column.header}</label>
                      <input
                        type="text"
                        className="w-full p-2 border rounded"
                        style={{ borderColor: styles.borderColor }}
                        placeholder={`Filter ${column.header.toLowerCase()}...`}
                        value={filters[column.id] || ''}
                        onChange={(e) => handleFilterChange(column.id, e.target.value)}
                      />
                    </div>
                  ))}
                </div>
                <div className="p-2 border-t" style={{ borderColor: styles.borderColor }}>
                  <button
                    className="w-full py-1 text-sm text-red-600 hover:bg-red-50 rounded"
                    onClick={() => setFilters({})}
                  >
                    Clear All Filters
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
      
      {/* Table */}
      <div className="overflow-x-auto">
        <table className="w-full border-collapse">
          <thead>
            <tr 
              style={{ backgroundColor: styles.headerBgColor, color: styles.headerTextColor }}
              ref={headerRef}
            >
              {/* Select all checkbox */}
              {features.multiSelect && (
                <th 
                  className="p-3 text-left first-col"
                  style={getBorderStyle()}
                >
                  <div className="flex items-center">
                    <button onClick={toggleSelectAll} className="mr-2">
                      {selectedRows.length === filteredData.length && filteredData.length > 0 ? (
                        <CheckSquare size={18} className="text-blue-500" />
                      ) : (
                        <Square size={18} className="text-gray-400" />
                      )}
                    </button>
                  </div>
                </th>
              )}
              
              {/* Expansion column */}
              {features.rowExpansion && renderExpandedRow && (
                <th 
                  className="w-10 p-3 text-left"
                  style={getBorderStyle()}
                ></th>
              )}
              
              {/* Column headers based on column order */}
              {columnOrder
                .filter(columnId => visibleColumns.includes(columnId))
                .map((columnId, index) => {
                  const column = columns.find(col => col.id === columnId);
                  if (!column) return null;
                  
                  return (
                    <th 
                      key={column.id}
                      className={`p-3 text-left ${index === 0 && !features.multiSelect && !features.rowExpansion ? 'first-col' : ''}`}
                      style={getBorderStyle()}
                      draggable={features.draggableColumns}
                      onDragStart={(e) => handleColumnDragStart(e, index)}
                      onDragOver={(e) => handleColumnDragOver(e, index)}
                      onDragEnd={handleColumnDragEnd}
                    >
                      <div 
                        className="flex items-center cursor-pointer"
                        onClick={() => requestSort(column.id)}
                      >
                        {column.header}
                        {sortConfig.key === column.id ? (
                          <ChevronDown 
                            size={16} 
                            className={`ml-1 ${sortConfig.direction === 'desc' ? 'transform rotate-180' : ''}`} 
                          />
                        ) : (
                          <ChevronDown size={16} className="ml-1 opacity-0 group-hover:opacity-50" />
                        )}
                      </div>
                    </th>
                  );
                })}
            </tr>
          </thead>
          
          <tbody>
            {filteredData.map((row, rowIndex) => {
              const isExpanded = expandedRows.includes(row.id);
              const isSelected = selectedRows.includes(row.id);
              
              return (
                <React.Fragment key={row.id}>
                  <tr 
                    className={`hover:bg-gray-50`}
                    style={{ 
                      backgroundColor: isSelected ? styles.selectedRowColor : 'inherit',
                      ':hover': { backgroundColor: styles.rowHoverColor }
                    }}
                    onClick={() => {
                      if (onRowClick) onRowClick(row);
                      if (features.rowExpansion && renderExpandedRow) toggleRowExpansion(row.id);
                    }}
                    draggable={features.draggableRows}
                    onDragStart={(e) => handleRowDragStart(e, rowIndex)}
                    onDragOver={(e) => handleRowDragOver(e, rowIndex)}
                    onDragEnd={handleRowDragEnd}
                  >
                    {/* Row selection checkbox */}
                    {features.multiSelect && (
                      <td 
                        className={`${getRowHeightClass()} p-3 first-col`}
                        style={getBorderStyle()}
                      >
                        <button onClick={(e) => toggleRowSelection(e, row.id)}>
                          {isSelected ? (
                            <CheckSquare size={18} className="text-blue-500" />
                          ) : (
                            <Square size={18} className="text-gray-400" />
                          )}
                        </button>
                      </td>
                    )}
                    
                    {/* Expansion control */}
                    {features.rowExpansion && renderExpandedRow && (
                      <td 
                        className={`${getRowHeightClass()} w-10 p-3`}
                        style={getBorderStyle()}
                        onClick={(e) => {
                          e.stopPropagation();
                          toggleRowExpansion(row.id);
                        }}
                      >
                        {isExpanded ? (
                          <ChevronDown size={18} className="text-gray-500" />
                        ) : (
                          <ChevronRight size={18} className="text-gray-500" />
                        )}
                      </td>
                    )}
                    
                    {/* Data cells */}
                    {columnOrder
                      .filter(columnId => visibleColumns.includes(columnId))
                      .map((columnId, index) => {
                        const isEditing = editingCell && 
                          editingCell.rowId === row.id && 
                          editingCell.columnId === columnId;
                        
                        return (
                          <td 
                            key={`${row.id}-${columnId}`}
                            className={`${getRowHeightClass()} p-3 ${index === 0 && !features.multiSelect && !features.rowExpansion ? 'first-col' : ''}`}
                            style={getBorderStyle()}
                            onDoubleClick={() => handleCellDoubleClick(row.id, columnId, row[columnId])}
                          >
                            {isEditing ? (
                              <input
                                type="text"
                                className="w-full p-1 border rounded"
                                style={{ borderColor: styles.borderColor }}
                                defaultValue={editingCell.value}
                                ref={editCellInputRef}
                                onBlur={handleCellEditComplete}
                                onKeyDown={(e) => {
                                  if (e.key === 'Enter') {
                                    handleCellEditComplete(e);
                                  } else if (e.key === 'Escape') {
                                    setEditingCell(null);
                                  }
                                }}
                              />
                            ) : (
                              renderCellValue(row, columnId)
                            )}
                          </td>
                        );
                      })}
                  </tr>
                  
                  {/* Expanded row content */}
                  {isExpanded && features.rowExpansion && renderExpandedRow && (
                    <tr>
                      <td 
                        colSpan={visibleColumns.length + (features.multiSelect ? 1 : 0) + 1}
                        className="p-0"
                        style={getBorderStyle()}
                      >
                        <div className="p-4 bg-gray-50" style={{ borderColor: styles.borderColor }}>
                          {renderExpandedRow(row)}
                        </div>
                      </td>
                    </tr>
                  )}
                </React.Fragment>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
};